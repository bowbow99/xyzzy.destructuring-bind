;;; -*- mode: lisp; package: test.destructuring-bind.invalid-lambda-list -*-
;;;
;;; tests/destructuring-bind/invalid-lambda-list.lt
;;;

;;; Code:

(require "destructuring-bind")
(require "lisp-unit")

(defpackage :test.destructuring-bind.invalid-lambda-list
  (:use :lisp :lisp-unit))

(in-package :test.destructuring-bind.invalid-lambda-list)

(remove-all-tests :test.destructuring-bind.invalid-lambda-list)


(defmacro assert-lambda-list-validity (valid-p lambda-list)
  (let ((expand-form `(macroexpand-1 '(destructuring-bind ,lambda-list nil nil))))
    (if valid-p
      `(assert-true (multiple-value-bind (#:expn #1=#:p) ,expand-form #1#))
      `(assert-error 'invalid-lambda-list ,expand-form))))

;;;;
;;;; * &whole

(define-test &whole-parameter--atomic
  (assert-lambda-list-validity t (&whole var))
  (progn
    (assert-lambda-list-validity nil (&whole "foo"))
    (assert-lambda-list-validity nil (&whole 123))))

(define-test &whole-parameter--compound
  ;; when &whole parameter is a list, it is destructuring-pattern
  (assert-lambda-list-validity t (&whole (a)))
  (assert-lambda-list-validity t (&whole (a b)))
  (assert-lambda-list-validity t (&whole (a b . c))))

(define-test &whole-parameter--number-of-parameters
  (assert-lambda-list-validity nil (&whole))
  (assert-lambda-list-validity t (&whole a))
  ;; NOTE: you can put more than one parameter after &whole, but those
  ;; are treated as &required parameter except first one.
  (assert-lambda-list-validity t (&whole a b)))


;;;;
;;;; * &required

(define-test &required-parameter--atomic
  (assert-lambda-list-validity t (x))
  (progn
    (assert-lambda-list-validity nil ("foo"))
    (assert-lambda-list-validity nil (33))
    (assert-lambda-list-validity nil (:foo))))

(define-test &required-parameter--compound
  (assert-lambda-list-validity t ((a)))
  (assert-lambda-list-validity t ((a b)))
  (assert-lambda-list-validity t ((a b . c))))

(define-test &required-parameter--number-of-parameters
  (assert-lambda-list-validity t ())
  (assert-lambda-list-validity t (a))
  (assert-lambda-list-validity t (a b))
  (assert-lambda-list-validity t (a b c)))


;;;;
;;;; * &optional

(define-test &optional-parameter--atomic
  (assert-lambda-list-validity t (&optional x))
  (progn
    (assert-lambda-list-validity nil (&optional "foo"))
    (assert-lambda-list-validity nil (&optional 33))
    (assert-lambda-list-validity nil (&optional :foo))))

(define-test &optional-parameter--compound
  ;; wrapped but without init-form
  (assert-lambda-list-validity t (&optional (var)))
  (progn
    (assert-lambda-list-validity nil (&optional ("var")))
    (assert-lambda-list-validity nil (&optional (:var))))
  ;; with init-form
  (assert-lambda-list-validity t (&optional (var :init-form)))
  (progn
    ;; init-form can be any kind of form
    (assert-lambda-list-validity t (&optional (var t)))
    (assert-lambda-list-validity t (&optional (var nil)))
    (assert-lambda-list-validity t (&optional (var "hogera fugera")))
    (assert-lambda-list-validity t (&optional (var (hogera (fugera))))))
  ;; with init-form + sp-var
  (assert-lambda-list-validity t (&optional (var :init-form sp-var)))
  (progn
    ;; sp-var must be a variable
    (assert-lambda-list-validity nil (&optional (var :init-form "sp-var")))
    (assert-lambda-list-validity nil (&optional (var :init-form :sp-var)))
    (assert-lambda-list-validity nil (&optional (var :init-form (hogera (fugera))))))
  ;; destructuring
  (assert-lambda-list-validity t (&optional ((a b . c))))
  (assert-lambda-list-validity t (&optional ((a b . c) :init-form)))
  (assert-lambda-list-validity t (&optional ((a b . c) :init-form sp-var)))
  )

(define-test &optional-parameter--number-of-parameters
  ;; &optional take any number of parameters
  (assert-lambda-list-validity t (&optional))
  (assert-lambda-list-validity t (&optional a))
  (assert-lambda-list-validity t (&optional a b))
  (assert-lambda-list-validity t (&optional a b c)))


;;;;
;;;; * &rest

;;;;
;;;; * &key


;;; * &allow-other-keys

;;;;
;;;; * &aux

(define-test &aux-parameter--atomic
  ;; just variable
  (assert-lambda-list-validity t (&aux var))
  (progn
    ;; var must be a variable
    (assert-lambda-list-validity nil (&aux "var"))
    (assert-lambda-list-validity nil (&aux :var))))

(define-test &aux-parameter--compound
  ;; var with init-form
  (assert-lambda-list-validity t (&aux (var value)))
  (progn
    ;; var must be variable
    (assert-lambda-list-validity nil (&aux ("var" value)))
    (assert-lambda-list-validity nil (&aux (:var  value)))
    ;; destructuring is not allowed here
    (assert-lambda-list-validity nil (&aux ((a b) value)))
    (assert-lambda-list-validity nil (&aux ((a . b) value))))
  (progn
    ;; init-form can be omitted
    (assert-lambda-list-validity t (&aux (var)))
    ;; init-form can be any form
    (assert-lambda-list-validity t (&aux (var (foo (bar baz)))))
    (assert-lambda-list-validity t (&aux (var "value")))
    (assert-lambda-list-validity t (&aux (var :value))))
  (progn
    ;; there's no room for other things
    (assert-lambda-list-validity nil (&aux (var value FOO)))
    (assert-lambda-list-validity nil (&aux (var value FOO BAR)))))

(define-test &aux-parameter--number-of-parameters
  ;; you can put any number of parameters in &aux
  (assert-lambda-list-validity t (&aux))
  (assert-lambda-list-validity t (&aux a))
  (assert-lambda-list-validity t (&aux a b))
  (assert-lambda-list-validity t (&aux a b c)))


;;; tests/destructuring-bind/invalid-lambda-list.lt ends here
